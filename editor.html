<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Level Editor - Game Stage Designer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
            color: #eee;
            overflow: hidden;
            height: 100vh;
        }

        /* ìƒë‹¨ íˆ´ë°” */
        .toolbar {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: #16213e;
            border-bottom: 2px solid #0f3460;
        }

        .toolbar input[type="text"] {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            background: #0f3460;
            color: #fff;
            width: 200px;
        }

        .toolbar button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background: #e94560;
            color: #fff;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        .toolbar button:hover {
            background: #ff6b6b;
        }

        .toolbar button.secondary {
            background: #0f3460;
        }

        .toolbar button.secondary:hover {
            background: #1a4a7a;
        }

        /* ë©”ì¸ ì»¨í…Œì´ë„ˆ */
        .main-container {
            display: flex;
            height: calc(100vh - 52px);
        }

        /* ë„êµ¬ íŒ¨ë„ */
        .tool-panel {
            width: 120px;
            background: #16213e;
            padding: 15px 10px;
            border-right: 2px solid #0f3460;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .tool-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px 8px;
            border: 2px solid transparent;
            border-radius: 8px;
            background: #0f3460;
            color: #aaa;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 11px;
        }

        .tool-btn:hover {
            background: #1a4a7a;
            color: #fff;
        }

        .tool-btn.active {
            border-color: #e94560;
            background: #2a1a3a;
            color: #fff;
        }

        .tool-btn .icon {
            font-size: 24px;
            margin-bottom: 4px;
        }

        .tool-btn .shortcut {
            font-size: 9px;
            color: #666;
            margin-top: 2px;
        }

        .tool-btn .sub-type {
            font-size: 10px;
            color: #e94560;
            background: rgba(233, 69, 96, 0.2);
            padding: 2px 6px;
            border-radius: 4px;
            margin-top: 3px;
        }

        /* ìº”ë²„ìŠ¤ ì˜ì—­ */
        .canvas-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .canvas-wrapper {
            flex: 1;
            overflow: auto;
            background: #111;
            position: relative;
        }

        #editorCanvas {
            display: block;
            cursor: crosshair;
        }

        /* í•˜ë‹¨ íŒ¨ë„ */
        .bottom-panel {
            display: flex;
            height: 200px;
            border-top: 2px solid #0f3460;
        }

        /* ì†ì„± íŒ¨ë„ */
        .property-panel {
            width: 300px;
            background: #16213e;
            padding: 15px;
            overflow-y: auto;
            border-right: 2px solid #0f3460;
        }

        .property-panel h3 {
            color: #e94560;
            margin-bottom: 15px;
            font-size: 14px;
        }

        .property-group {
            margin-bottom: 12px;
        }

        .property-group label {
            display: block;
            font-size: 11px;
            color: #888;
            margin-bottom: 4px;
        }

        .property-group input, .property-group select {
            width: 100%;
            padding: 6px 10px;
            border: none;
            border-radius: 4px;
            background: #0f3460;
            color: #fff;
            font-size: 13px;
        }

        .property-row {
            display: flex;
            gap: 10px;
        }

        .property-row .property-group {
            flex: 1;
        }

        /* JSON íŒ¨ë„ */
        .json-panel {
            flex: 1;
            background: #0d1117;
            padding: 10px;
            display: flex;
            flex-direction: column;
        }

        .json-panel h3 {
            color: #e94560;
            margin-bottom: 10px;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .json-panel h3 button {
            padding: 4px 10px;
            font-size: 11px;
            background: #238636;
        }

        .json-panel h3 button:hover {
            background: #2ea043;
        }

        #jsonOutput {
            flex: 1;
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 4px;
            padding: 10px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
            color: #c9d1d9;
            overflow: auto;
            resize: none;
        }

        /* ì„œë¸Œ ë„êµ¬ íŒ¨ë„ - í”Œë¡œíŒ… */
        .sub-tool-panel {
            display: none;
            position: fixed;
            top: 70px;
            left: 140px;
            padding: 15px 20px;
            background: linear-gradient(135deg, #1a1a3a 0%, #2a2a5a 100%);
            border-radius: 12px;
            border: 2px solid #e94560;
            box-shadow: 0 8px 32px rgba(233, 69, 96, 0.3);
            z-index: 100;
            min-width: 200px;
        }

        .sub-tool-panel.active {
            display: block;
            animation: fadeIn 0.2s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .sub-tool-panel label {
            display: block;
            font-size: 14px;
            font-weight: bold;
            color: #e94560;
            margin-bottom: 10px;
        }

        .sub-tool-panel select {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #4a4a8a;
            border-radius: 8px;
            background: #0f3460;
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .sub-tool-panel select:hover {
            border-color: #e94560;
            background: #1a4a7a;
        }

        .sub-tool-panel select:focus {
            outline: none;
            border-color: #ff6b6b;
            box-shadow: 0 0 10px rgba(233, 69, 96, 0.5);
        }

        .sub-tool-panel select option {
            padding: 10px;
            font-size: 14px;
            background: #16213e;
        }

        /* ì¤Œ ì»¨íŠ¸ë¡¤ */
        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-left: auto;
            color: #888;
            font-size: 12px;
        }

        .zoom-controls button {
            width: 28px;
            height: 28px;
            padding: 0;
            font-size: 16px;
        }

        /* ìƒíƒœë°” */
        .status-bar {
            padding: 5px 15px;
            background: #0f3460;
            font-size: 11px;
            color: #888;
            display: flex;
            gap: 20px;
        }

        .status-bar span {
            color: #aaa;
        }

        /* íˆë“  íŒŒì¼ ì¸í’‹ */
        #fileInput {
            display: none;
        }

        /* ëª¨ë‹¬ */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: #16213e;
            padding: 25px;
            border-radius: 8px;
            min-width: 400px;
        }

        .modal-content h3 {
            margin-bottom: 20px;
            color: #e94560;
        }

        .modal-content .btn-row {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: flex-end;
        }
    </style>
</head>
<body>
    <!-- ìƒë‹¨ íˆ´ë°” -->
    <div class="toolbar">
        <input type="text" id="stageName" placeholder="íŒŒì¼ëª… (ì˜ˆ: Stage001)" value="Stage000" style="width: 140px;">
        <input type="text" id="stageDisplayName" placeholder="ë§µ ì´ë¦„ (ì˜ˆ: ì´ˆì› ì§€ëŒ€)" value="" style="width: 160px;">
        <button onclick="saveJSON()">ì €ì¥ (JSON)</button>
        <button class="secondary" onclick="loadJSON()">ë¶ˆëŸ¬ì˜¤ê¸°</button>
        <button class="secondary" onclick="newStage()">ìƒˆë¡œ ë§Œë“¤ê¸°</button>
        <button class="secondary" onclick="copyToClipboard()">í´ë¦½ë³´ë“œ ë³µì‚¬</button>
        <button onclick="applyToGameJS()" style="background: #238636;">game.js ì ìš©</button>
        <button onclick="previewMap()" style="background: #9333ea;">ë¯¸ë¦¬ë³´ê¸°</button>
        <button class="secondary" onclick="setDefaultFolder()" title="ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸° ê¸°ë³¸ í´ë” ì„¤ì •">ğŸ“ í´ë” ì„¤ì •</button>
        <span id="folderStatus" style="color: #888; font-size: 11px; margin-left: 5px;"></span>
        <input type="file" id="fileInput" accept=".json" onchange="loadJSON(event)">

        <div class="zoom-controls">
            <button class="secondary" onclick="zoomOut()">-</button>
            <span id="zoomLevel">100%</span>
            <button class="secondary" onclick="zoomIn()">+</button>
            <button class="secondary" onclick="resetZoom()">Reset</button>
        </div>
    </div>

    <div class="main-container">
        <!-- ë„êµ¬ íŒ¨ë„ -->
        <div class="tool-panel">
            <div class="tool-btn active" data-tool="select" onclick="setTool('select')">
                <span class="icon">ğŸ–±ï¸</span>
                <span>ì„ íƒ</span>
                <span class="shortcut">[1]</span>
            </div>
            <div class="tool-btn" data-tool="platform" onclick="setTool('platform')">
                <span class="icon">ğŸ“¦</span>
                <span>í”Œë«í¼</span>
                <span class="shortcut">[2]</span>
            </div>
            <div class="tool-btn" data-tool="monster" onclick="setTool('monster')">
                <span class="icon">ğŸ‘¾</span>
                <span>ëª¬ìŠ¤í„°</span>
                <span class="sub-type" id="monsterTypeLabel"></span>
                <span class="shortcut">[3]</span>
            </div>
            <div class="tool-btn" data-tool="item" onclick="setTool('item')">
                <span class="icon">â­</span>
                <span>ì•„ì´í…œ</span>
                <span class="sub-type" id="itemTypeLabel"></span>
                <span class="shortcut">[4]</span>
            </div>
            <div class="tool-btn" data-tool="portal" onclick="setTool('portal')">
                <span class="icon">ğŸŒ€</span>
                <span>í¬íƒˆ</span>
                <span class="shortcut">[5]</span>
            </div>
            <div class="tool-btn" data-tool="spawner" onclick="setTool('spawner')">
                <span class="icon">ğŸ’€</span>
                <span>ìŠ¤í¬ë„ˆ</span>
                <span class="sub-type" id="spawnerTypeLabel"></span>
                <span class="shortcut">[6]</span>
            </div>
            <div class="tool-btn" data-tool="ladder" onclick="setTool('ladder')">
                <span class="icon">ğŸªœ</span>
                <span>ì‚¬ë‹¤ë¦¬</span>
                <span class="shortcut">[7]</span>
            </div>
            <div class="tool-btn" data-tool="playerStart" onclick="setTool('playerStart')">
                <span class="icon">ğŸƒ</span>
                <span>ì‹œì‘ì </span>
                <span class="shortcut">[8]</span>
            </div>

            <!-- ì„œë¸Œ ë„êµ¬ íŒ¨ë„ë“¤ -->
            <div class="sub-tool-panel" id="monsterSubTool">
                <label>ğŸ¯ ëª¬ìŠ¤í„° ì„ íƒ (ID)</label>
                <select id="monsterType" onchange="updateSubTypeLabel('monster')">
                </select>
            </div>

            <div class="sub-tool-panel" id="itemSubTool">
                <label>ğŸ¯ ì•„ì´í…œ íƒ€ì… ì„ íƒ</label>
                <select id="itemType" onchange="updateSubTypeLabel('item')">
                    <option value="potion">â¤ï¸ í¬ì…˜</option>
                    <option value="lightning">âš¡ ë²ˆê°œ</option>
                    <option value="fireball">ğŸ”¥ í™”ì—¼êµ¬</option>
                    <option value="shuriken">âœ¦ í‘œì°½</option>
                </select>
            </div>

            <div class="sub-tool-panel" id="spawnerSubTool">
                <label>ğŸ¯ ìŠ¤í¬ë„ˆ ëª¬ìŠ¤í„° ì„ íƒ (ID)</label>
                <select id="spawnerType" onchange="updateSubTypeLabel('spawner')">
                </select>
                <label>â±ï¸ ìŠ¤í° ì£¼ê¸° (ì´ˆ)</label>
                <input type="number" id="spawnerInterval" value="5" min="1" max="60" step="0.5">
                <label>ğŸ‘¾ ìµœëŒ€ ëª¬ìŠ¤í„° ìˆ˜</label>
                <input type="number" id="spawnerMaxMonsters" value="2" min="1" max="10">
            </div>
        </div>

        <!-- ìº”ë²„ìŠ¤ ì˜ì—­ -->
        <div class="canvas-container">
            <div class="canvas-wrapper" id="canvasWrapper">
                <canvas id="editorCanvas"></canvas>
            </div>

            <!-- í•˜ë‹¨ íŒ¨ë„ -->
            <div class="bottom-panel">
                <!-- ì†ì„± íŒ¨ë„ -->
                <div class="property-panel">
                    <h3>ì†ì„±</h3>
                    <div id="propertyContent">
                        <p style="color: #666; font-size: 12px;">ì˜¤ë¸Œì íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”</p>
                    </div>
                </div>

                <!-- ë°°ê²½ ì„¤ì • íŒ¨ë„ -->
                <div class="property-panel" style="width: 250px;">
                    <h3>ë°°ê²½ ì„¤ì •</h3>
                    <div class="property-row">
                        <div class="property-group">
                            <label>í•˜ëŠ˜ ìƒë‹¨</label>
                            <input type="color" id="bgSkyTop" value="#87CEEB" onchange="updateBackground()">
                        </div>
                        <div class="property-group">
                            <label>í•˜ëŠ˜ í•˜ë‹¨</label>
                            <input type="color" id="bgSkyBottom" value="#E0F6FF" onchange="updateBackground()">
                        </div>
                    </div>
                    <div class="property-group">
                        <label>ë°°ê²½ í”„ë¦¬ì…‹</label>
                        <select id="bgPreset" onchange="applyBgPreset()">
                            <option value="custom">ì‚¬ìš©ì ì •ì˜</option>
                            <option value="grassland">ì´ˆì›</option>
                            <option value="cave">ë™êµ´</option>
                            <option value="desert">ì‚¬ë§‰</option>
                            <option value="night">ë°¤</option>
                            <option value="sunset">ì„ì–‘</option>
                            <option value="village">ë§ˆì„</option>
                        </select>
                    </div>
                    <div class="property-group">
                        <label>ì‚° ìƒ‰ìƒ</label>
                        <input type="color" id="bgMountainColor1" value="#9DC183" onchange="updateBackground()" style="width: 45%;">
                        <input type="color" id="bgMountainColor2" value="#7CAF6B" onchange="updateBackground()" style="width: 45%;">
                    </div>
                </div>

                <!-- JSON íŒ¨ë„ -->
                <div class="json-panel">
                    <h3>
                        JSON ì¶œë ¥
                        <button onclick="copyToClipboard()">ë³µì‚¬</button>
                    </h3>
                    <textarea id="jsonOutput" readonly></textarea>
                </div>
            </div>

            <!-- ìƒíƒœë°” -->
            <div class="status-bar">
                <div>ë§ˆìš°ìŠ¤: <span id="mousePos">0, 0</span></div>
                <div>ì¤Œ: <span id="zoomStatus">100%</span></div>
                <div>ë„êµ¬: <span id="toolStatus">ì„ íƒ</span></div>
                <div>ì˜¤ë¸Œì íŠ¸: <span id="objectCount">0</span></div>
            </div>
        </div>
    </div>

    <!-- í¬íƒˆ ì„¤ì • ëª¨ë‹¬ -->
    <div class="modal" id="portalModal">
        <div class="modal-content">
            <h3>í¬íƒˆ ì„¤ì •</h3>
            <div class="property-group">
                <label>ì´ë™í•  ìŠ¤í…Œì´ì§€ (Stage í´ë”ì˜ JSON íŒŒì¼ëª…)</label>
                <input type="text" id="portalTargetStage" placeholder="ì˜ˆ: Stage001" value="Stage001">
                <div style="margin-top: 8px; font-size: 11px; color: #888;">
                    ê¸°ì¡´ ìŠ¤í…Œì´ì§€: <span id="stageList" style="color: #4a9eff;">Lobby, Stage001, Stage002, Stage003</span>
                </div>
            </div>
            <div class="btn-row">
                <button class="secondary" onclick="closePortalModal()">ì·¨ì†Œ</button>
                <button onclick="confirmPortal()">í™•ì¸</button>
            </div>
        </div>
    </div>

    <!-- ëª¬ìŠ¤í„° ë°ì´í„° ë¡œë“œ -->
    <script src="Monster/Monster.js"></script>

    <script>
        // ìƒìˆ˜
        const WORLD_WIDTH = 1920;
        const WORLD_HEIGHT = 810;
        const GRID_SIZE = 32;
        const FLOOR_Y = 760;

        // ìº”ë²„ìŠ¤ ì„¤ì •
        const canvas = document.getElementById('editorCanvas');
        const ctx = canvas.getContext('2d');
        const wrapper = document.getElementById('canvasWrapper');

        // ëª¬ìŠ¤í„° ë°ì´í„°
        let monsterData = [];

        // ì—ë””í„° ìƒíƒœ
        let zoom = 1;
        let currentTool = 'select';
        let selectedObject = null;
        let isDragging = false;
        let isDrawing = false;
        let dragStart = { x: 0, y: 0 };
        let drawStart = { x: 0, y: 0 };
        let pendingPortalPos = null;

        // ìŠ¤í…Œì´ì§€ ë°ì´í„°
        let stageData = {
            number: 0,
            displayName: "",
            playerStart: { x: 100, y: 500 },
            platforms: [],
            monsters: [],
            items: [],
            portals: [],
            spawners: [],
            ladders: [],
            background: {
                skyTop: '#87CEEB',
                skyBottom: '#E0F6FF',
                mountains: [
                    { x1: 0, peak: 150, x2: 300, color: '#9DC183' },
                    { x1: 200, peak: 200, x2: 600, color: '#7CAF6B' },
                    { x1: 500, peak: 120, x2: 900, color: '#9DC183' },
                    { x1: 800, peak: 180, x2: 1200, color: '#7CAF6B' },
                    { x1: 1100, peak: 140, x2: 1400, color: '#9DC183' },
                    { x1: 1300, peak: 160, x2: 1600, color: '#7CAF6B' }
                ],
                houses: []
            }
        };

        // Undo íˆìŠ¤í† ë¦¬
        const MAX_HISTORY = 20;
        let history = [];

        function saveState() {
            const state = JSON.parse(JSON.stringify(stageData));
            history.push(state);
            if (history.length > MAX_HISTORY) {
                history.shift();
            }
        }

        function undo() {
            if (history.length === 0) return;
            stageData = history.pop();
            selectedObject = null;
            updateJSON();
            render();
        }

        // ëª¬ìŠ¤í„° ë°ì´í„° ë¡œë“œ
        function loadMonsterData() {
            if (typeof MONSTER_DATA !== 'undefined') {
                monsterData = MONSTER_DATA;
                console.log('ëª¬ìŠ¤í„° ë°ì´í„° ë¡œë“œ ì™„ë£Œ:', monsterData.length + 'ì¢…');
            } else {
                console.error('ëª¬ìŠ¤í„° ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨: MONSTER_DATA ì—†ìŒ');
                monsterData = [
                    { id: 100001, type: 'slime', name: 'ìŠ¬ë¼ì„' },
                    { id: 100002, type: 'mushroom', name: 'ë²„ì„¯' },
                    { id: 100003, type: 'ghost', name: 'ìœ ë ¹' }
                ];
            }
            populateMonsterDropdowns();
        }

        // ëª¬ìŠ¤í„° ë“œë¡­ë‹¤ìš´ ì±„ìš°ê¸°
        function populateMonsterDropdowns() {
            const monsterSelect = document.getElementById('monsterType');
            const spawnerSelect = document.getElementById('spawnerType');

            const optionsHtml = monsterData.map(m =>
                `<option value="${m.id}">${m.name} (${m.id})</option>`
            ).join('');

            monsterSelect.innerHTML = optionsHtml;
            spawnerSelect.innerHTML = optionsHtml;

            // ë¼ë²¨ ì—…ë°ì´íŠ¸
            updateSubTypeLabel('monster');
            updateSubTypeLabel('spawner');
            updateSubTypeLabel('item');
        }

        // ëª¬ìŠ¤í„° IDë¡œ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
        function getMonsterById(id) {
            return monsterData.find(m => m.id === parseInt(id) || m.id === id);
        }

        // ëª¬ìŠ¤í„° ì´ë¦„ ê°€ì ¸ì˜¤ê¸°
        function getMonsterName(id) {
            const monster = getMonsterById(id);
            return monster ? monster.name : id;
        }

        // ì´ˆê¸°í™”
        function init() {
            loadMonsterData();

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('contextmenu', onContextMenu);
            canvas.addEventListener('wheel', onWheel);

            document.addEventListener('keydown', onKeyDown);

            // ì €ì¥ëœ í´ë” ì„¤ì • ë³µì›
            restoreSavedFolder();

            updateBgUI();
            updateJSON();
            render();
        }

        function resizeCanvas() {
            canvas.width = WORLD_WIDTH * zoom;
            canvas.height = WORLD_HEIGHT * zoom;
            render();
        }

        // ì„œë¸Œíƒ€ì… ë¼ë²¨ ì—…ë°ì´íŠ¸
        function updateSubTypeLabel(type) {
            const itemNames = { potion: 'í¬ì…˜', lightning: 'ë²ˆê°œ', fireball: 'í™”ì—¼êµ¬', shuriken: 'í‘œì°½' };

            const selectId = type + 'Type';
            const labelId = type + 'TypeLabel';
            const value = document.getElementById(selectId).value;
            const label = document.getElementById(labelId);

            if (label) {
                if (type === 'item') {
                    label.textContent = itemNames[value] || value;
                } else {
                    label.textContent = getMonsterName(value);
                }
            }
        }

        // ë„êµ¬ ì„¤ì •
        function setTool(tool) {
            currentTool = tool;
            selectedObject = null;

            // ë²„íŠ¼ ìŠ¤íƒ€ì¼ ì—…ë°ì´íŠ¸
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.tool === tool) {
                    btn.classList.add('active');
                }
            });

            // ì„œë¸Œ ë„êµ¬ íŒ¨ë„ í‘œì‹œ
            document.querySelectorAll('.sub-tool-panel').forEach(p => p.classList.remove('active'));
            if (tool === 'monster') {
                document.getElementById('monsterSubTool').classList.add('active');
            } else if (tool === 'item') {
                document.getElementById('itemSubTool').classList.add('active');
            } else if (tool === 'spawner') {
                document.getElementById('spawnerSubTool').classList.add('active');
            }

            // ì»¤ì„œ ì—…ë°ì´íŠ¸
            canvas.style.cursor = tool === 'select' ? 'default' : 'crosshair';

            // ìƒíƒœë°” ì—…ë°ì´íŠ¸
            const toolNames = {
                select: 'ì„ íƒ', platform: 'í”Œë«í¼', monster: 'ëª¬ìŠ¤í„°',
                item: 'ì•„ì´í…œ', portal: 'í¬íƒˆ', spawner: 'ìŠ¤í¬ë„ˆ', ladder: 'ì‚¬ë‹¤ë¦¬', playerStart: 'ì‹œì‘ì '
            };
            document.getElementById('toolStatus').textContent = toolNames[tool];

            updatePropertyPanel();
            render();
        }

        // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (e.clientX - rect.left) / zoom,
                y: (e.clientY - rect.top) / zoom
            };
        }

        function snapToGrid(value) {
            return Math.round(value / GRID_SIZE) * GRID_SIZE;
        }

        function onMouseDown(e) {
            const pos = getMousePos(e);

            if (e.button === 0) { // ì¢Œí´ë¦­
                if (currentTool === 'select') {
                    // ì˜¤ë¸Œì íŠ¸ ì„ íƒ
                    selectedObject = findObjectAt(pos.x, pos.y);
                    if (selectedObject) {
                        saveState();
                        isDragging = true;
                        dragStart = { x: pos.x - selectedObject.obj.x, y: pos.y - selectedObject.obj.y };
                    }
                } else if (currentTool === 'platform') {
                    // í”Œë«í¼ ê·¸ë¦¬ê¸° ì‹œì‘
                    isDrawing = true;
                    drawStart = { x: snapToGrid(pos.x), y: snapToGrid(pos.y) };
                } else if (currentTool === 'ladder') {
                    // ì‚¬ë‹¤ë¦¬ ê·¸ë¦¬ê¸° ì‹œì‘ (ìœ„ì—ì„œ ì•„ë˜ë¡œ ë“œë˜ê·¸)
                    isDrawing = true;
                    drawStart = { x: snapToGrid(pos.x), y: snapToGrid(pos.y) };
                } else if (currentTool === 'monster') {
                    addMonster(pos.x, pos.y);
                } else if (currentTool === 'item') {
                    addItem(pos.x, pos.y);
                } else if (currentTool === 'portal') {
                    openPortalModal(pos.x, pos.y);
                } else if (currentTool === 'spawner') {
                    addSpawner(pos.x, pos.y);
                } else if (currentTool === 'playerStart') {
                    setPlayerStart(pos.x, pos.y);
                }
            }

            updatePropertyPanel();
            render();
        }

        function onMouseMove(e) {
            const pos = getMousePos(e);

            // ìƒíƒœë°” ì—…ë°ì´íŠ¸
            document.getElementById('mousePos').textContent =
                `${Math.round(pos.x)}, ${Math.round(pos.y)}`;

            if (isDragging && selectedObject) {
                selectedObject.obj.x = snapToGrid(pos.x - dragStart.x);
                selectedObject.obj.y = snapToGrid(pos.y - dragStart.y);
                updateJSON();
                updatePropertyPanel();
            }

            render();

            // í”Œë«í¼ ë¯¸ë¦¬ë³´ê¸°
            if (isDrawing && currentTool === 'platform') {
                const endX = snapToGrid(pos.x);
                const endY = snapToGrid(pos.y);
                const previewRect = {
                    x: Math.min(drawStart.x, endX),
                    y: Math.min(drawStart.y, endY),
                    width: Math.abs(endX - drawStart.x) || GRID_SIZE,
                    height: Math.abs(endY - drawStart.y) || GRID_SIZE
                };

                ctx.save();
                ctx.scale(zoom, zoom);
                ctx.fillStyle = 'rgba(139, 90, 43, 0.5)';
                ctx.strokeStyle = '#fff';
                ctx.setLineDash([5, 5]);
                ctx.fillRect(previewRect.x, previewRect.y, previewRect.width, previewRect.height);
                ctx.strokeRect(previewRect.x, previewRect.y, previewRect.width, previewRect.height);
                ctx.restore();
            }

            // ì‚¬ë‹¤ë¦¬ ë¯¸ë¦¬ë³´ê¸°
            if (isDrawing && currentTool === 'ladder') {
                const endY = snapToGrid(pos.y);
                const ladderX = drawStart.x;
                const ladderY = Math.min(drawStart.y, endY);
                const ladderHeight = Math.abs(endY - drawStart.y) || GRID_SIZE * 2;

                ctx.save();
                ctx.scale(zoom, zoom);
                ctx.strokeStyle = 'rgba(139, 69, 19, 0.7)';
                ctx.lineWidth = 4;
                ctx.setLineDash([5, 5]);
                // ì„¸ë¡œ ë ˆì¼
                ctx.beginPath();
                ctx.moveTo(ladderX - 12, ladderY);
                ctx.lineTo(ladderX - 12, ladderY + ladderHeight);
                ctx.moveTo(ladderX + 12, ladderY);
                ctx.lineTo(ladderX + 12, ladderY + ladderHeight);
                ctx.stroke();
                // ê°€ë¡œ ë°œíŒ
                ctx.lineWidth = 3;
                const rungSpacing = 20;
                for (let ry = ladderY + 10; ry < ladderY + ladderHeight; ry += rungSpacing) {
                    ctx.beginPath();
                    ctx.moveTo(ladderX - 12, ry);
                    ctx.lineTo(ladderX + 12, ry);
                    ctx.stroke();
                }
                ctx.restore();
            }
        }

        function onMouseUp(e) {
            const pos = getMousePos(e);

            if (isDrawing && currentTool === 'platform') {
                const endX = snapToGrid(pos.x);
                const endY = snapToGrid(pos.y);
                const platform = {
                    x: Math.min(drawStart.x, endX),
                    y: Math.min(drawStart.y, endY),
                    width: Math.abs(endX - drawStart.x) || GRID_SIZE,
                    height: Math.abs(endY - drawStart.y) || GRID_SIZE
                };

                if (platform.width >= GRID_SIZE && platform.height >= GRID_SIZE) {
                    saveState();
                    stageData.platforms.push(platform);
                    updateJSON();
                }
            }

            if (isDrawing && currentTool === 'ladder') {
                const endY = snapToGrid(pos.y);
                const ladder = {
                    x: drawStart.x,
                    y: Math.min(drawStart.y, endY),
                    height: Math.abs(endY - drawStart.y) || GRID_SIZE * 4
                };

                if (ladder.height >= GRID_SIZE * 2) {
                    saveState();
                    stageData.ladders.push(ladder);
                    updateJSON();
                }
            }

            isDragging = false;
            isDrawing = false;
            render();
        }

        function onContextMenu(e) {
            e.preventDefault();
            const pos = getMousePos(e);
            const obj = findObjectAt(pos.x, pos.y);

            if (obj) {
                deleteObject(obj);
            }
        }

        function onWheel(e) {
            e.preventDefault();
            if (e.deltaY < 0) {
                zoomIn();
            } else {
                zoomOut();
            }
        }

        // ì˜¤ë¸Œì íŠ¸ ì°¾ê¸°
        function findObjectAt(x, y) {
            // í”Œë ˆì´ì–´ ì‹œì‘ì 
            const ps = stageData.playerStart;
            if (x >= ps.x - 16 && x <= ps.x + 48 && y >= ps.y - 48 && y <= ps.y) {
                return { type: 'playerStart', obj: ps };
            }

            // í¬íƒˆ
            for (let i = stageData.portals.length - 1; i >= 0; i--) {
                const p = stageData.portals[i];
                if (x >= p.x - 25 && x <= p.x + 25 && y >= p.y - 50 && y <= p.y) {
                    return { type: 'portal', obj: p, index: i };
                }
            }

            // ìŠ¤í¬ë„ˆ
            for (let i = stageData.spawners.length - 1; i >= 0; i--) {
                const s = stageData.spawners[i];
                if (x >= s.x - 20 && x <= s.x + 20 && y >= s.y - 20 && y <= s.y + 20) {
                    return { type: 'spawner', obj: s, index: i };
                }
            }

            // ì•„ì´í…œ
            for (let i = stageData.items.length - 1; i >= 0; i--) {
                const item = stageData.items[i];
                if (x >= item.x - 15 && x <= item.x + 15 && y >= item.y - 15 && y <= item.y + 15) {
                    return { type: 'item', obj: item, index: i };
                }
            }

            // ëª¬ìŠ¤í„°
            for (let i = stageData.monsters.length - 1; i >= 0; i--) {
                const m = stageData.monsters[i];
                if (x >= m.x - 20 && x <= m.x + 20 && y >= m.y - 20 && y <= m.y + 20) {
                    return { type: 'monster', obj: m, index: i };
                }
            }

            // ì‚¬ë‹¤ë¦¬
            for (let i = stageData.ladders.length - 1; i >= 0; i--) {
                const l = stageData.ladders[i];
                if (x >= l.x - 16 && x <= l.x + 16 && y >= l.y && y <= l.y + l.height) {
                    return { type: 'ladder', obj: l, index: i };
                }
            }

            // í”Œë«í¼
            for (let i = stageData.platforms.length - 1; i >= 0; i--) {
                const p = stageData.platforms[i];
                if (x >= p.x && x <= p.x + p.width && y >= p.y && y <= p.y + p.height) {
                    return { type: 'platform', obj: p, index: i };
                }
            }

            return null;
        }

        // ì˜¤ë¸Œì íŠ¸ ì¶”ê°€
        function addMonster(x, y) {
            saveState();
            const monsterId = parseInt(document.getElementById('monsterType').value);
            stageData.monsters.push({
                x: snapToGrid(x),
                y: snapToGrid(y),
                monsterId: monsterId
            });
            updateJSON();
        }

        function addItem(x, y) {
            saveState();
            const type = document.getElementById('itemType').value;
            stageData.items.push({
                x: snapToGrid(x),
                y: snapToGrid(y),
                type: type
            });
            updateJSON();
        }

        function addSpawner(x, y) {
            saveState();
            const monsterId = parseInt(document.getElementById('spawnerType').value);
            const intervalSec = parseFloat(document.getElementById('spawnerInterval').value) || 5;
            const maxMonsters = parseInt(document.getElementById('spawnerMaxMonsters').value) || 2;
            stageData.spawners.push({
                x: snapToGrid(x),
                y: snapToGrid(y),
                monsterId: monsterId,
                spawnInterval: Math.round(intervalSec * 60),
                maxMonsters: maxMonsters
            });
            updateJSON();
        }

        function setPlayerStart(x, y) {
            saveState();
            stageData.playerStart.x = snapToGrid(x);
            stageData.playerStart.y = snapToGrid(y);
            updateJSON();
        }

        function openPortalModal(x, y) {
            pendingPortalPos = { x: snapToGrid(x), y: snapToGrid(y) };
            document.getElementById('portalTargetStage').value = 'Stage001';
            document.getElementById('portalModal').classList.add('active');
        }

        function closePortalModal() {
            document.getElementById('portalModal').classList.remove('active');
            pendingPortalPos = null;
        }

        function confirmPortal() {
            if (pendingPortalPos) {
                const targetStage = document.getElementById('portalTargetStage').value.trim();

                if (!targetStage) {
                    alert('ì´ë™í•  ìŠ¤í…Œì´ì§€ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”. (ì˜ˆ: Stage001)');
                    return;
                }

                saveState();
                stageData.portals.push({
                    x: pendingPortalPos.x,
                    y: pendingPortalPos.y,
                    targetStage: targetStage
                });
                updateJSON();
                render();
            }
            closePortalModal();
        }

        // ì˜¤ë¸Œì íŠ¸ ì‚­ì œ
        function deleteObject(obj) {
            if (!obj) return;
            saveState();

            if (obj.type === 'platform') {
                stageData.platforms.splice(obj.index, 1);
            } else if (obj.type === 'monster') {
                stageData.monsters.splice(obj.index, 1);
            } else if (obj.type === 'item') {
                stageData.items.splice(obj.index, 1);
            } else if (obj.type === 'portal') {
                stageData.portals.splice(obj.index, 1);
            } else if (obj.type === 'spawner') {
                stageData.spawners.splice(obj.index, 1);
            } else if (obj.type === 'ladder') {
                stageData.ladders.splice(obj.index, 1);
            }
            // playerStartëŠ” ì‚­ì œ ë¶ˆê°€

            selectedObject = null;
            updateJSON();
            updatePropertyPanel();
            render();
        }

        // í‚¤ë³´ë“œ ì´ë²¤íŠ¸
        function onKeyDown(e) {
            // ì…ë ¥ í•„ë“œì—ì„œëŠ” ë‹¨ì¶•í‚¤ ë¹„í™œì„±í™”
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            switch(e.key) {
                case '1': setTool('select'); break;
                case '2': setTool('platform'); break;
                case '3': setTool('monster'); break;
                case '4': setTool('item'); break;
                case '5': setTool('portal'); break;
                case '6': setTool('spawner'); break;
                case '7': setTool('ladder'); break;
                case '8': setTool('playerStart'); break;
                case 'Delete':
                case 'Backspace':
                    if (selectedObject) {
                        deleteObject(selectedObject);
                    }
                    break;
                case 's':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        saveJSON();
                    }
                    break;
                case 'c':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        copyToClipboard();
                    }
                    break;
                case 'z':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        undo();
                    }
                    break;
            }
        }

        // ì¤Œ
        function zoomIn() {
            if (zoom < 2) {
                zoom = Math.min(2, zoom + 0.1);
                updateZoom();
            }
        }

        function zoomOut() {
            if (zoom > 0.3) {
                zoom = Math.max(0.3, zoom - 0.1);
                updateZoom();
            }
        }

        function resetZoom() {
            zoom = 1;
            updateZoom();
        }

        function updateZoom() {
            const zoomPercent = Math.round(zoom * 100) + '%';
            document.getElementById('zoomLevel').textContent = zoomPercent;
            document.getElementById('zoomStatus').textContent = zoomPercent;
            resizeCanvas();
        }

        // ì†ì„± íŒ¨ë„ ì—…ë°ì´íŠ¸
        function updatePropertyPanel() {
            const content = document.getElementById('propertyContent');

            if (!selectedObject) {
                content.innerHTML = '<p style="color: #666; font-size: 12px;">ì˜¤ë¸Œì íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”</p>';
                return;
            }

            const obj = selectedObject.obj;
            let html = '';

            html += `<div class="property-row">
                <div class="property-group">
                    <label>X</label>
                    <input type="number" value="${obj.x}" onchange="updateProperty('x', this.value)">
                </div>
                <div class="property-group">
                    <label>Y</label>
                    <input type="number" value="${obj.y}" onchange="updateProperty('y', this.value)">
                </div>
            </div>`;

            if (selectedObject.type === 'platform') {
                html += `<div class="property-row">
                    <div class="property-group">
                        <label>ë„ˆë¹„</label>
                        <input type="number" value="${obj.width}" onchange="updateProperty('width', this.value)">
                    </div>
                    <div class="property-group">
                        <label>ë†’ì´</label>
                        <input type="number" value="${obj.height}" onchange="updateProperty('height', this.value)">
                    </div>
                </div>`;
            }

            if (selectedObject.type === 'monster') {
                const monsterInfo = getMonsterById(obj.monsterId);
                const monsterOptions = monsterData.map(m =>
                    `<option value="${m.id}" ${obj.monsterId === m.id ? 'selected' : ''}>${m.name} (${m.id})</option>`
                ).join('');
                html += `<div class="property-group">
                    <label>ëª¬ìŠ¤í„°</label>
                    <select onchange="updateProperty('monsterId', parseInt(this.value))">
                        ${monsterOptions}
                    </select>
                </div>`;
            }

            if (selectedObject.type === 'item') {
                html += `<div class="property-group">
                    <label>íƒ€ì…</label>
                    <select onchange="updateProperty('type', this.value)">
                        <option value="potion" ${obj.type === 'potion' ? 'selected' : ''}>í¬ì…˜</option>
                        <option value="lightning" ${obj.type === 'lightning' ? 'selected' : ''}>ë²ˆê°œ</option>
                        <option value="fireball" ${obj.type === 'fireball' ? 'selected' : ''}>í™”ì—¼êµ¬</option>
                        <option value="shuriken" ${obj.type === 'shuriken' ? 'selected' : ''}>í‘œì°½</option>
                    </select>
                </div>`;
            }

            if (selectedObject.type === 'portal') {
                html += `<div class="property-group">
                    <label>ì´ë™í•  ìŠ¤í…Œì´ì§€ (íŒŒì¼ëª…)</label>
                    <input type="text" value="${obj.targetStage}" onchange="updateProperty('targetStage', this.value)">
                </div>`;
            }

            if (selectedObject.type === 'spawner') {
                const monsterOptions = monsterData.map(m =>
                    `<option value="${m.id}" ${obj.monsterId === m.id ? 'selected' : ''}>${m.name} (${m.id})</option>`
                ).join('');
                html += `<div class="property-group">
                    <label>ëª¬ìŠ¤í„°</label>
                    <select onchange="updateProperty('monsterId', parseInt(this.value))">
                        ${monsterOptions}
                    </select>
                </div>`;
                const intervalSec = (obj.spawnInterval || 300) / 60;
                html += `<div class="property-group">
                    <label>ìŠ¤í° ì£¼ê¸° (ì´ˆ)</label>
                    <input type="number" value="${intervalSec}" min="1" max="60" step="0.5" onchange="updateProperty('spawnInterval', Math.round(parseFloat(this.value) * 60))">
                </div>`;
                html += `<div class="property-group">
                    <label>ìµœëŒ€ ëª¬ìŠ¤í„° ìˆ˜</label>
                    <input type="number" value="${obj.maxMonsters || 2}" min="1" max="10" onchange="updateProperty('maxMonsters', parseInt(this.value))">
                </div>`;
            }

            if (selectedObject.type === 'ladder') {
                html += `<div class="property-group">
                    <label>ë†’ì´</label>
                    <input type="number" value="${obj.height}" onchange="updateProperty('height', this.value)">
                </div>`;
            }

            content.innerHTML = html;
        }

        function updateProperty(prop, value) {
            if (!selectedObject) return;
            saveState();

            if (prop === 'x' || prop === 'y' || prop === 'width' || prop === 'height') {
                value = parseInt(value);
            }

            selectedObject.obj[prop] = value;
            updateJSON();
            render();
        }

        // JSON ê´€ë¦¬
        function updateJSON() {
            const stageName = document.getElementById('stageName').value;
            stageData.number = parseInt(stageName.replace(/\D/g, '')) || 0;
            stageData.displayName = document.getElementById('stageDisplayName').value;

            const output = JSON.stringify(stageData, null, 2);
            document.getElementById('jsonOutput').value = output;

            // ì˜¤ë¸Œì íŠ¸ ì¹´ìš´íŠ¸ ì—…ë°ì´íŠ¸
            const count = stageData.platforms.length + stageData.monsters.length +
                         stageData.items.length + stageData.portals.length + stageData.spawners.length +
                         stageData.ladders.length;
            document.getElementById('objectCount').textContent = count;
        }

        // ì €ì¥ëœ ë””ë ‰í† ë¦¬ í•¸ë“¤ (File System Access APIìš©)
        let savedDirectoryHandle = null;
        const DB_NAME = 'EditorSettingsDB';
        const STORE_NAME = 'settings';

        // IndexedDB ì´ˆê¸°í™”
        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 1);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME);
                    }
                };
            });
        }

        // ë””ë ‰í† ë¦¬ í•¸ë“¤ ì €ì¥
        async function saveDirectoryHandle(handle) {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE_NAME, 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                const request = store.put(handle, 'directoryHandle');
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        // ë””ë ‰í† ë¦¬ í•¸ë“¤ ë¶ˆëŸ¬ì˜¤ê¸°
        async function loadDirectoryHandle() {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE_NAME, 'readonly');
                const store = tx.objectStore(STORE_NAME);
                const request = store.get('directoryHandle');
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        // ì €ì¥ëœ í´ë” ë³µì›
        async function restoreSavedFolder() {
            try {
                const handle = await loadDirectoryHandle();
                if (handle) {
                    // ê¶Œí•œ í™•ì¸ ë° ìš”ì²­
                    const permission = await handle.queryPermission({ mode: 'readwrite' });
                    if (permission === 'granted') {
                        savedDirectoryHandle = handle;
                        document.getElementById('folderStatus').textContent = 'ğŸ“‚ ' + handle.name;
                    } else if (permission === 'prompt') {
                        // ì‚¬ìš©ìê°€ ì²« ìƒí˜¸ì‘ìš© ì‹œ ê¶Œí•œ ìš”ì²­
                        document.getElementById('folderStatus').textContent = 'ğŸ“‚ ' + handle.name + ' (í´ë¦­í•˜ì—¬ ê¶Œí•œ í—ˆìš©)';
                        document.getElementById('folderStatus').style.cursor = 'pointer';
                        document.getElementById('folderStatus').onclick = async () => {
                            const newPermission = await handle.requestPermission({ mode: 'readwrite' });
                            if (newPermission === 'granted') {
                                savedDirectoryHandle = handle;
                                document.getElementById('folderStatus').textContent = 'ğŸ“‚ ' + handle.name;
                                document.getElementById('folderStatus').style.cursor = 'default';
                                document.getElementById('folderStatus').onclick = null;
                            }
                        };
                    }
                }
            } catch (err) {
                console.warn('ì €ì¥ëœ í´ë” ë³µì› ì‹¤íŒ¨:', err);
            }
        }

        // ê¸°ë³¸ í´ë” ì„¤ì • í•¨ìˆ˜
        async function setDefaultFolder() {
            if (!('showDirectoryPicker' in window)) {
                alert('ì´ ë¸Œë¼ìš°ì €ëŠ” í´ë” ì„ íƒ ê¸°ëŠ¥ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                return;
            }

            try {
                savedDirectoryHandle = await window.showDirectoryPicker({
                    mode: 'readwrite'
                });
                const folderName = savedDirectoryHandle.name;
                document.getElementById('folderStatus').textContent = 'ğŸ“‚ ' + folderName;
                document.getElementById('folderStatus').style.cursor = 'default';
                document.getElementById('folderStatus').onclick = null;

                // IndexedDBì— ì €ì¥
                await saveDirectoryHandle(savedDirectoryHandle);

                alert('ê¸°ë³¸ í´ë”ê°€ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤: ' + folderName + '\n\nì´ì œ ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸° ì‹œ ì´ í´ë”ê°€ ê¸°ë³¸ìœ¼ë¡œ ì—´ë¦½ë‹ˆë‹¤.\n(ì—ë””í„°ë¥¼ ë‹¤ì‹œ ì—´ì–´ë„ ìœ ì§€ë©ë‹ˆë‹¤)');
            } catch (err) {
                if (err.name !== 'AbortError') {
                    console.error('í´ë” ì„ íƒ ì˜¤ë¥˜:', err);
                }
            }
        }

        async function saveJSON() {
            updateJSON();
            const data = JSON.stringify(stageData, null, 2);
            const stageName = document.getElementById('stageName').value || 'Stage000';
            const fileName = stageName.replace(/[^a-zA-Z0-9ê°€-í£_-]/g, '_') + '.json';

            // File System Access API ì§€ì› í™•ì¸
            if ('showSaveFilePicker' in window) {
                try {
                    const handle = await window.showSaveFilePicker({
                        suggestedName: fileName,
                        startIn: savedDirectoryHandle || 'documents',
                        types: [{
                            description: 'JSON Files',
                            accept: { 'application/json': ['.json'] }
                        }]
                    });

                    const writable = await handle.createWritable();
                    await writable.write(data);
                    await writable.close();

                    alert('ì €ì¥ ì™„ë£Œ: ' + handle.name);
                    return;
                } catch (err) {
                    if (err.name === 'AbortError') {
                        return; // ì‚¬ìš©ìê°€ ì·¨ì†Œí•¨
                    }
                    console.warn('File System Access API ì‹¤íŒ¨, ê¸°ë³¸ ë‹¤ìš´ë¡œë“œë¡œ ì „í™˜:', err);
                }
            }

            // í´ë°±: ê¸°ì¡´ ë‹¤ìš´ë¡œë“œ ë°©ì‹
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            a.click();
            URL.revokeObjectURL(url);
        }

        async function loadJSON(e) {
            let file;

            // File System Access API ì§€ì› ì‹œ íŒŒì¼ ì„ íƒ ëŒ€í™”ìƒì ì‚¬ìš©
            if ('showOpenFilePicker' in window && !e) {
                try {
                    const [handle] = await window.showOpenFilePicker({
                        startIn: savedDirectoryHandle || 'documents',
                        types: [{
                            description: 'JSON Files',
                            accept: { 'application/json': ['.json'] }
                        }]
                    });
                    file = await handle.getFile();
                } catch (err) {
                    if (err.name === 'AbortError') return;
                    console.warn('File System Access API ì‹¤íŒ¨:', err);
                    document.getElementById('fileInput').click();
                    return;
                }
            } else if (e && e.target && e.target.files) {
                file = e.target.files[0];
                if (!file) return;
            } else {
                document.getElementById('fileInput').click();
                return;
            }

            // íŒŒì¼ëª…ì—ì„œ .json ì œê±°í•˜ì—¬ ê¸°ë³¸ ì´ë¦„ìœ¼ë¡œ ì‚¬ìš©
            const fileNameWithoutExt = file.name.replace(/\.json$/i, '');

            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    const data = JSON.parse(event.target.result);
                    const loadedNumber = data.number || parseInt(fileNameWithoutExt.replace(/\D/g, '')) || 0;
                    const defaultBg = {
                        skyTop: '#87CEEB',
                        skyBottom: '#E0F6FF',
                        mountains: [
                            { x1: 0, peak: 150, x2: 300, color: '#9DC183' },
                            { x1: 200, peak: 200, x2: 600, color: '#7CAF6B' },
                            { x1: 500, peak: 120, x2: 900, color: '#9DC183' },
                            { x1: 800, peak: 180, x2: 1200, color: '#7CAF6B' },
                            { x1: 1100, peak: 140, x2: 1400, color: '#9DC183' },
                            { x1: 1300, peak: 160, x2: 1600, color: '#7CAF6B' }
                        ]
                    };
                    history = [];
                    stageData = {
                        number: loadedNumber,
                        displayName: data.displayName || "",
                        playerStart: data.playerStart || { x: 100, y: 500 },
                        platforms: data.platforms || [],
                        monsters: data.monsters || [],
                        items: data.items || [],
                        portals: data.portals || [],
                        spawners: data.spawners || [],
                        ladders: data.ladders || [],
                        background: data.background || defaultBg
                    };
                    document.getElementById('stageName').value = fileNameWithoutExt || `Stage${String(loadedNumber).padStart(3, '0')}`;
                    document.getElementById('stageDisplayName').value = stageData.displayName;
                    updateBgUI();
                    selectedObject = null;
                    updateJSON();
                    updatePropertyPanel();
                    render();
                    alert('ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ: ' + file.name);
                } catch (err) {
                    alert('JSON íŒŒì¼ íŒŒì‹± ì˜¤ë¥˜: ' + err.message);
                }
            };
            reader.readAsText(file);
            if (e && e.target) e.target.value = '';
        }

        function copyToClipboard() {
            updateJSON();
            const text = document.getElementById('jsonOutput').value;
            navigator.clipboard.writeText(text).then(() => {
                alert('JSONì´ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!');
            });
        }

        // game.js íŒŒì¼ í•¸ë“¤ ì €ì¥
        let gameJSHandle = null;

        function generateStageJS() {
            const stageName = document.getElementById('stageName').value || 'Stage000';

            let js = `    "${stageName}": {\n`;
            js += `        number: ${stageData.number},\n`;
            js += `        displayName: "${stageData.displayName}",\n`;
            js += `        playerStart: { x: ${stageData.playerStart.x}, y: ${stageData.playerStart.y} },\n`;

            js += `        platforms: [\n`;
            stageData.platforms.forEach((p, i) => {
                js += `            { x: ${p.x}, y: ${p.y}, width: ${p.width}, height: ${p.height} }`;
                js += i < stageData.platforms.length - 1 ? ',\n' : '\n';
            });
            js += `        ],\n`;

            js += `        portals: [\n`;
            stageData.portals.forEach((p, i) => {
                js += `            { x: ${p.x}, y: ${p.y}, targetStage: "${p.targetStage}" }`;
                js += i < stageData.portals.length - 1 ? ',\n' : '\n';
            });
            js += `        ],\n`;

            js += `        items: [\n`;
            stageData.items.forEach((item, i) => {
                js += `            { x: ${item.x}, y: ${item.y}, type: '${item.type}' }`;
                js += i < stageData.items.length - 1 ? ',\n' : '\n';
            });
            js += `        ],\n`;

            js += `        monsters: [\n`;
            stageData.monsters.forEach((m, i) => {
                js += `            { x: ${m.x}, y: ${m.y}, monsterId: ${m.monsterId} }`;
                js += i < stageData.monsters.length - 1 ? ',\n' : '\n';
            });
            js += `        ],\n`;

            js += `        spawners: [\n`;
            stageData.spawners.forEach((s, i) => {
                const interval = s.spawnInterval || 300;
                const max = s.maxMonsters || 2;
                js += `            { x: ${s.x}, y: ${s.y}, monsterId: ${s.monsterId}, spawnInterval: ${interval}, maxMonsters: ${max} }`;
                js += i < stageData.spawners.length - 1 ? ',\n' : '\n';
            });
            js += `        ],\n`;

            js += `        ladders: [\n`;
            stageData.ladders.forEach((l, i) => {
                js += `            { x: ${l.x}, y: ${l.y}, height: ${l.height} }`;
                js += i < stageData.ladders.length - 1 ? ',\n' : '\n';
            });
            js += `        ],\n`;

            const bg = stageData.background;
            js += `        background: {\n`;
            js += `            skyTop: '${bg.skyTop}',\n`;
            js += `            skyBottom: '${bg.skyBottom}',\n`;
            js += `            mountains: [\n`;
            bg.mountains.forEach((m, i) => {
                js += `                { x1: ${m.x1}, peak: ${m.peak}, x2: ${m.x2}, color: '${m.color}' }`;
                js += i < bg.mountains.length - 1 ? ',\n' : '\n';
            });
            js += `            ],\n`;
            js += `            houses: [\n`;
            if (bg.houses && bg.houses.length > 0) {
                bg.houses.forEach((h, i) => {
                    js += `                { x: ${h.x}, width: ${h.width}, height: ${h.height}, roofHeight: ${h.roofHeight}, wallColor: '${h.wallColor}', roofColor: '${h.roofColor}' }`;
                    js += i < bg.houses.length - 1 ? ',\n' : '\n';
                });
            }
            js += `            ]\n`;
            js += `        }\n`;
            js += `    }`;

            return { stageName, js };
        }

        async function applyToGameJS() {
            updateJSON();

            if (!('showOpenFilePicker' in window)) {
                alert('ì´ ë¸Œë¼ìš°ì €ëŠ” íŒŒì¼ ì§ì ‘ ìˆ˜ì •ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                return;
            }

            try {
                // game.js íŒŒì¼ ì„ íƒ (ì²˜ìŒ í•œ ë²ˆë§Œ)
                if (!gameJSHandle) {
                    alert('game.js íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
                    const [handle] = await window.showOpenFilePicker({
                        types: [{ description: 'JavaScript Files', accept: { 'text/javascript': ['.js'] } }]
                    });
                    gameJSHandle = handle;
                }

                // íŒŒì¼ ì½ê¸°
                const file = await gameJSHandle.getFile();
                let content = await file.text();

                const { stageName, js } = generateStageJS();

                // í•´ë‹¹ ìŠ¤í…Œì´ì§€ ì°¾ì•„ì„œ êµì²´
                const stageRegex = new RegExp(
                    `(\\s*"${stageName}"\\s*:\\s*\\{[\\s\\S]*?\\n    \\})`,
                    'g'
                );

                if (stageRegex.test(content)) {
                    // ê¸°ì¡´ ìŠ¤í…Œì´ì§€ êµì²´
                    content = content.replace(stageRegex, js);
                } else {
                    // ìƒˆ ìŠ¤í…Œì´ì§€ ì¶”ê°€ (stages ê°ì²´ì˜ ë§ˆì§€ë§‰ }; ì•ì—)
                    const insertPoint = content.lastIndexOf('};');
                    if (insertPoint !== -1) {
                        // ë§ˆì§€ë§‰ ìŠ¤í…Œì´ì§€ ë’¤ì— ì½¤ë§ˆ ì¶”ê°€ í•„ìš”
                        const beforeInsert = content.substring(0, insertPoint);
                        const lastBraceIndex = beforeInsert.lastIndexOf('}');
                        if (lastBraceIndex !== -1 && !beforeInsert.substring(lastBraceIndex).includes(',')) {
                            content = beforeInsert.substring(0, lastBraceIndex + 1) + ',' + beforeInsert.substring(lastBraceIndex + 1) + js + '\n' + content.substring(insertPoint);
                        } else {
                            content = beforeInsert + js + ',\n' + content.substring(insertPoint);
                        }
                    }
                }

                // íŒŒì¼ ì“°ê¸°
                const writable = await gameJSHandle.createWritable();
                await writable.write(content);
                await writable.close();

                alert(`âœ… game.jsì— "${stageName}" ìŠ¤í…Œì´ì§€ê°€ ì ìš©ë˜ì—ˆìŠµë‹ˆë‹¤!\n\nê²Œì„ì„ ìƒˆë¡œê³ ì¹¨í•˜ë©´ ë³€ê²½ì‚¬í•­ì´ ë°˜ì˜ë©ë‹ˆë‹¤.`);

            } catch (err) {
                if (err.name === 'AbortError') return;
                console.error('game.js ìˆ˜ì • ì‹¤íŒ¨:', err);
                alert('game.js ìˆ˜ì • ì‹¤íŒ¨: ' + err.message);
                gameJSHandle = null;
            }
        }

        function previewMap() {
            updateJSON();
            localStorage.setItem('editorPreviewStage', JSON.stringify(stageData));
            window.open('index.html?preview=1', '_blank');
        }

        function newStage() {
            if (!confirm('í˜„ì¬ ì‘ì—…ì„ ì§€ìš°ê³  ìƒˆ ìŠ¤í…Œì´ì§€ë¥¼ ë§Œë“œì‹œê² ìŠµë‹ˆê¹Œ?')) return;

            history = [];
            stageData = {
                number: 0,
                displayName: "",
                playerStart: { x: 100, y: 500 },
                platforms: [],
                monsters: [],
                items: [],
                portals: [],
                spawners: [],
                ladders: [],
                background: {
                    skyTop: '#87CEEB',
                    skyBottom: '#E0F6FF',
                    mountains: [
                        { x1: 0, peak: 150, x2: 300, color: '#9DC183' },
                        { x1: 200, peak: 200, x2: 600, color: '#7CAF6B' },
                        { x1: 500, peak: 120, x2: 900, color: '#9DC183' },
                        { x1: 800, peak: 180, x2: 1200, color: '#7CAF6B' },
                        { x1: 1100, peak: 140, x2: 1400, color: '#9DC183' },
                        { x1: 1300, peak: 160, x2: 1600, color: '#7CAF6B' }
                    ]
                }
            };
            document.getElementById('stageName').value = "Stage000";
            document.getElementById('stageDisplayName').value = stageData.displayName;
            updateBgUI();
            selectedObject = null;
            updateJSON();
            updatePropertyPanel();
            render();
        }

        // ë°°ê²½ UI ì—…ë°ì´íŠ¸
        function updateBgUI() {
            document.getElementById('bgSkyTop').value = stageData.background.skyTop;
            document.getElementById('bgSkyBottom').value = stageData.background.skyBottom;
            if (stageData.background.mountains.length >= 2) {
                document.getElementById('bgMountainColor1').value = stageData.background.mountains[0].color;
                document.getElementById('bgMountainColor2').value = stageData.background.mountains[1].color;
            }
        }

        // ë°°ê²½ ì—…ë°ì´íŠ¸
        function updateBackground() {
            saveState();
            stageData.background.skyTop = document.getElementById('bgSkyTop').value;
            stageData.background.skyBottom = document.getElementById('bgSkyBottom').value;
            const color1 = document.getElementById('bgMountainColor1').value;
            const color2 = document.getElementById('bgMountainColor2').value;
            stageData.background.mountains.forEach((m, i) => {
                m.color = i % 2 === 0 ? color1 : color2;
            });
            document.getElementById('bgPreset').value = 'custom';
            updateJSON();
            render();
        }

        // ë°°ê²½ í”„ë¦¬ì…‹ ì ìš©
        function applyBgPreset() {
            const preset = document.getElementById('bgPreset').value;
            const presets = {
                grassland: { skyTop: '#87CEEB', skyBottom: '#E0F6FF', mt1: '#9DC183', mt2: '#7CAF6B' },
                cave: { skyTop: '#1a1a2e', skyBottom: '#2d2d44', mt1: '#3d3d5c', mt2: '#2d2d44' },
                desert: { skyTop: '#f4a460', skyBottom: '#ffe4b5', mt1: '#deb887', mt2: '#d2b48c' },
                night: { skyTop: '#0a0a23', skyBottom: '#1a1a3a', mt1: '#2a2a4a', mt2: '#1a1a3a' },
                sunset: { skyTop: '#ff7e5f', skyBottom: '#feb47b', mt1: '#8B4513', mt2: '#A0522D' },
                village: {
                    skyTop: '#7EC8E3', skyBottom: '#F5F5DC', mt1: '#6B8E23', mt2: '#556B2F',
                    houses: [
                        { x: 100, width: 80, height: 70, roofHeight: 40, wallColor: '#D2691E', roofColor: '#8B0000' },
                        { x: 300, width: 100, height: 90, roofHeight: 50, wallColor: '#DEB887', roofColor: '#A0522D' },
                        { x: 550, width: 70, height: 60, roofHeight: 35, wallColor: '#F4A460', roofColor: '#800000' },
                        { x: 750, width: 90, height: 80, roofHeight: 45, wallColor: '#D2B48C', roofColor: '#8B4513' },
                        { x: 1000, width: 85, height: 75, roofHeight: 42, wallColor: '#DEB887', roofColor: '#A52A2A' },
                        { x: 1200, width: 75, height: 65, roofHeight: 38, wallColor: '#F5DEB3', roofColor: '#800000' }
                    ]
                }
            };
            if (preset === 'custom' || !presets[preset]) return;

            saveState();
            const p = presets[preset];
            stageData.background.skyTop = p.skyTop;
            stageData.background.skyBottom = p.skyBottom;
            stageData.background.mountains.forEach((m, i) => {
                m.color = i % 2 === 0 ? p.mt1 : p.mt2;
            });
            // ì§‘ ì ìš©
            if (p.houses) {
                stageData.background.houses = JSON.parse(JSON.stringify(p.houses));
            } else {
                stageData.background.houses = [];
            }
            updateBgUI();
            updateJSON();
            render();
        }

        // ë Œë”ë§
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.scale(zoom, zoom);

            // ë°°ê²½ (í•˜ëŠ˜)
            const bg = stageData.background;
            const gradient = ctx.createLinearGradient(0, 0, 0, WORLD_HEIGHT);
            gradient.addColorStop(0, bg.skyTop);
            gradient.addColorStop(1, bg.skyBottom);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);

            // ì‚° ê·¸ë¦¬ê¸°
            if (bg.mountains) {
                bg.mountains.forEach(mt => {
                    ctx.fillStyle = mt.color;
                    ctx.beginPath();
                    ctx.moveTo(mt.x1, FLOOR_Y);
                    ctx.lineTo((mt.x1 + mt.x2) / 2, FLOOR_Y - mt.peak);
                    ctx.lineTo(mt.x2, FLOOR_Y);
                    ctx.fill();
                });
            }

            // ì§‘ ê·¸ë¦¬ê¸°
            if (bg.houses) {
                bg.houses.forEach(house => {
                    // ì§‘ ëª¸ì²´
                    ctx.fillStyle = house.wallColor || '#D2691E';
                    ctx.fillRect(house.x, FLOOR_Y - house.height, house.width, house.height);

                    // ì§€ë¶•
                    ctx.fillStyle = house.roofColor || '#8B0000';
                    ctx.beginPath();
                    ctx.moveTo(house.x - 10, FLOOR_Y - house.height);
                    ctx.lineTo(house.x + house.width / 2, FLOOR_Y - house.height - house.roofHeight);
                    ctx.lineTo(house.x + house.width + 10, FLOOR_Y - house.height);
                    ctx.fill();

                    // ë¬¸
                    ctx.fillStyle = '#4A2810';
                    const doorW = house.width * 0.25;
                    const doorH = house.height * 0.5;
                    ctx.fillRect(house.x + house.width / 2 - doorW / 2, FLOOR_Y - doorH, doorW, doorH);

                    // ì°½ë¬¸
                    ctx.fillStyle = '#87CEEB';
                    const winSize = house.width * 0.2;
                    ctx.fillRect(house.x + house.width * 0.15, FLOOR_Y - house.height * 0.75, winSize, winSize);
                    ctx.fillRect(house.x + house.width * 0.65, FLOOR_Y - house.height * 0.75, winSize, winSize);
                });
            }

            // ê·¸ë¦¬ë“œ
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.lineWidth = 1;
            for (let x = 0; x <= WORLD_WIDTH; x += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, WORLD_HEIGHT);
                ctx.stroke();
            }
            for (let y = 0; y <= WORLD_HEIGHT; y += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(WORLD_WIDTH, y);
                ctx.stroke();
            }

            // ë°”ë‹¥ì„ 
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, FLOOR_Y);
            ctx.lineTo(WORLD_WIDTH, FLOOR_Y);
            ctx.stroke();

            // ë°”ë‹¥
            ctx.fillStyle = '#654321';
            ctx.fillRect(0, FLOOR_Y, WORLD_WIDTH, WORLD_HEIGHT - FLOOR_Y);

            // í”Œë«í¼
            stageData.platforms.forEach((p, i) => {
                const isSelected = selectedObject && selectedObject.type === 'platform' && selectedObject.index === i;

                ctx.fillStyle = '#8B5A2B';
                ctx.fillRect(p.x, p.y, p.width, p.height);

                ctx.strokeStyle = isSelected ? '#ff0' : '#654321';
                ctx.lineWidth = isSelected ? 3 : 2;
                ctx.strokeRect(p.x, p.y, p.width, p.height);

                // í”Œë«í¼ í‘œë©´
                ctx.fillStyle = '#228B22';
                ctx.fillRect(p.x, p.y, p.width, 5);
            });

            // ëª¬ìŠ¤í„°
            stageData.monsters.forEach((m, i) => {
                const isSelected = selectedObject && selectedObject.type === 'monster' && selectedObject.index === i;
                const monsterInfo = getMonsterById(m.monsterId);
                const monsterType = monsterInfo ? monsterInfo.type : 'slime';
                drawMonster(m.x, m.y, monsterType, isSelected, monsterInfo);
            });

            // ì•„ì´í…œ
            stageData.items.forEach((item, i) => {
                const isSelected = selectedObject && selectedObject.type === 'item' && selectedObject.index === i;
                drawItem(item.x, item.y, item.type, isSelected);
            });

            // í¬íƒˆ
            stageData.portals.forEach((p, i) => {
                const isSelected = selectedObject && selectedObject.type === 'portal' && selectedObject.index === i;
                drawPortal(p.x, p.y, p.targetStage, isSelected);
            });

            // ìŠ¤í¬ë„ˆ
            stageData.spawners.forEach((s, i) => {
                const isSelected = selectedObject && selectedObject.type === 'spawner' && selectedObject.index === i;
                const monsterInfo = getMonsterById(s.monsterId);
                const monsterName = monsterInfo ? monsterInfo.name : 'Unknown';
                drawSpawner(s.x, s.y, monsterName, isSelected);
            });

            // ì‚¬ë‹¤ë¦¬
            stageData.ladders.forEach((l, i) => {
                const isSelected = selectedObject && selectedObject.type === 'ladder' && selectedObject.index === i;
                drawLadder(l.x, l.y, l.height, isSelected);
            });

            // í”Œë ˆì´ì–´ ì‹œì‘ì 
            const isPlayerSelected = selectedObject && selectedObject.type === 'playerStart';
            drawPlayerStart(stageData.playerStart.x, stageData.playerStart.y, isPlayerSelected);

            // ê²½ê³„ì„ 
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 5]);
            ctx.strokeRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);
            ctx.setLineDash([]);

            ctx.restore();
        }

        function drawMonster(x, y, type, selected, monsterInfo) {
            ctx.save();

            // ëª¬ìŠ¤í„° í¬ê¸° (í…Œì´ë¸”ì—ì„œ ê°€ì ¸ì˜¤ê±°ë‚˜ ê¸°ë³¸ê°’ ì‚¬ìš©)
            const width = monsterInfo ? monsterInfo.width : 40;
            const height = monsterInfo ? monsterInfo.height : 36;
            const scale = Math.max(width, height) / 40; // ê¸°ë³¸ í¬ê¸° ëŒ€ë¹„ ìŠ¤ì¼€ì¼

            if (type === 'slime') {
                ctx.fillStyle = '#44ff44';
                ctx.beginPath();
                ctx.ellipse(x, y - height/3, width/2, height/2.5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.fillRect(x - width/5, y - height/2.5, 4 * scale, 4 * scale);
                ctx.fillRect(x + width/10, y - height/2.5, 4 * scale, 4 * scale);
            } else if (type === 'mushroom') {
                ctx.fillStyle = '#ffe4c4';
                ctx.fillRect(x - width/5, y - height/2, width/2.5, height/2);
                ctx.fillStyle = '#ff4444';
                ctx.beginPath();
                ctx.ellipse(x, y - height/1.6, width/2, height/3, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(x - width/5, y - height/1.4, 4 * scale, 0, Math.PI * 2);
                ctx.arc(x + width/5, y - height/1.8, 3 * scale, 0, Math.PI * 2);
                ctx.fill();
            } else if (type === 'ghost') {
                ctx.fillStyle = 'rgba(200, 200, 255, 0.8)';
                ctx.beginPath();
                ctx.ellipse(x, y - height/3, width/2, height/2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.fillRect(x - width/5, y - height/2, 5 * scale, 5 * scale);
                ctx.fillRect(x + width/12, y - height/2, 5 * scale, 5 * scale);
            } else if (type === 'ghostBoss') {
                // ë³´ìŠ¤ ìœ ë ¹ ëª¸í†µ (ë³´ë¼ìƒ‰)
                ctx.fillStyle = 'rgba(106, 13, 173, 0.85)';
                ctx.beginPath();
                ctx.ellipse(x, y - height/3, width/2, height/2, 0, 0, Math.PI * 2);
                ctx.fill();
                // ì™•ê´€
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.moveTo(x - width/3, y - height/1.5);
                ctx.lineTo(x - width/4, y - height/1.2);
                ctx.lineTo(x - width/8, y - height/1.4);
                ctx.lineTo(x, y - height/1.1);
                ctx.lineTo(x + width/8, y - height/1.4);
                ctx.lineTo(x + width/4, y - height/1.2);
                ctx.lineTo(x + width/3, y - height/1.5);
                ctx.closePath();
                ctx.fill();
                // ëˆˆ (ë…¸ë€ìƒ‰)
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(x - width/5, y - height/2, 5 * scale, 5 * scale);
                ctx.fillRect(x + width/12, y - height/2, 5 * scale, 5 * scale);
            } else if (type === 'ghostSlave') {
                // ë…¸ì˜ˆ ìœ ë ¹ ëª¸í†µ (ì´ˆë¡ìƒ‰)
                ctx.fillStyle = 'rgba(32, 178, 170, 0.7)';
                ctx.beginPath();
                ctx.ellipse(x, y - height/3, width/2, height/2, 0, 0, Math.PI * 2);
                ctx.fill();
                // ëˆˆ (ë¹¨ê°„ìƒ‰)
                ctx.fillStyle = '#ff3333';
                ctx.fillRect(x - width/5, y - height/2, 4 * scale, 4 * scale);
                ctx.fillRect(x + width/12, y - height/2, 4 * scale, 4 * scale);
            }

            // ëª¬ìŠ¤í„° ì´ë¦„ í‘œì‹œ
            if (monsterInfo) {
                ctx.fillStyle = '#fff';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(monsterInfo.name, x, y + 15);
            }

            if (selected) {
                ctx.strokeStyle = '#ff0';
                ctx.lineWidth = 2;
                ctx.strokeRect(x - width/2 - 5, y - height - 5, width + 10, height + 25);
            }

            ctx.restore();
        }

        function drawItem(x, y, type, selected) {
            ctx.save();

            if (type === 'potion') {
                ctx.fillStyle = '#ff6666';
                ctx.beginPath();
                ctx.moveTo(x, y - 20);
                ctx.lineTo(x + 10, y - 10);
                ctx.lineTo(x + 10, y + 10);
                ctx.lineTo(x - 10, y + 10);
                ctx.lineTo(x - 10, y - 10);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(x - 5, y - 25, 10, 8);
            } else if (type === 'lightning') {
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.moveTo(x + 5, y - 20);
                ctx.lineTo(x - 10, y);
                ctx.lineTo(x, y);
                ctx.lineTo(x - 5, y + 20);
                ctx.lineTo(x + 10, y);
                ctx.lineTo(x, y);
                ctx.closePath();
                ctx.fill();
            } else if (type === 'fireball') {
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.arc(x, y, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, Math.PI * 2);
                ctx.fill();
            } else if (type === 'shuriken') {
                // í‘œì°½ (4ë°©í–¥ ë‚ )
                ctx.fillStyle = '#5a5a5a';
                ctx.strokeStyle = '#3a3a3a';
                ctx.lineWidth = 1;
                for (let i = 0; i < 4; i++) {
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(i * Math.PI / 2);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-4, -4);
                    ctx.lineTo(0, -14);
                    ctx.lineTo(4, -4);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    ctx.restore();
                }
                // ì¤‘ì•™ ì›
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#7a7a7a';
                ctx.fill();
                ctx.stroke();
            }

            if (selected) {
                ctx.strokeStyle = '#ff0';
                ctx.lineWidth = 2;
                ctx.strokeRect(x - 18, y - 28, 36, 56);
            }

            ctx.restore();
        }

        function drawPortal(x, y, targetStage, selected) {
            ctx.save();

            // í¬íƒˆ ì´í™íŠ¸
            ctx.fillStyle = 'rgba(138, 43, 226, 0.7)';
            ctx.beginPath();
            ctx.ellipse(x, y - 25, 25, 35, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = 'rgba(75, 0, 130, 0.8)';
            ctx.beginPath();
            ctx.ellipse(x, y - 25, 15, 25, 0, 0, Math.PI * 2);
            ctx.fill();

            // í¬íƒˆ ì•„ì´ì½˜ (ì¤‘ì•™)
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('ğŸŒ€', x, y - 25);

            // ì´ë™í•  ìŠ¤í…Œì´ì§€ í‘œì‹œ
            ctx.fillStyle = '#ffff00';
            ctx.font = 'bold 11px Arial';
            ctx.textBaseline = 'alphabetic';
            const displayName = String(targetStage).length > 12
                ? String(targetStage).substring(0, 10) + '..'
                : targetStage;
            ctx.fillText('â†’ ' + displayName, x, y + 15);

            if (selected) {
                ctx.strokeStyle = '#ff0';
                ctx.lineWidth = 2;
                ctx.strokeRect(x - 30, y - 65, 60, 100);
            }

            ctx.restore();
        }

        function drawSpawner(x, y, monsterType, selected) {
            ctx.save();

            // ìŠ¤í¬ë„ˆ ë² ì´ìŠ¤
            ctx.fillStyle = '#333';
            ctx.fillRect(x - 20, y - 10, 40, 20);

            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(x, y, 8, 0, Math.PI * 2);
            ctx.fill();

            // íƒ€ì… í‘œì‹œ
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 9px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(monsterType, x, y + 25);

            if (selected) {
                ctx.strokeStyle = '#ff0';
                ctx.lineWidth = 2;
                ctx.strokeRect(x - 25, y - 15, 50, 45);
            }

            ctx.restore();
        }

        function drawLadder(x, y, height, selected) {
            ctx.save();

            const ladderWidth = 32;
            const railWidth = 4;
            const rungSpacing = 20;

            // ì„¸ë¡œ ë ˆì¼ (ì¢Œìš°)
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(x - ladderWidth/2, y, railWidth, height);
            ctx.fillRect(x + ladderWidth/2 - railWidth, y, railWidth, height);

            // ê°€ë¡œ ë°œíŒ
            ctx.fillStyle = '#A0522D';
            for (let ry = y + 10; ry < y + height; ry += rungSpacing) {
                ctx.fillRect(x - ladderWidth/2, ry, ladderWidth, 4);
            }

            // ë ˆì´ë¸”
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 9px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ğŸªœ', x, y - 5);

            if (selected) {
                ctx.strokeStyle = '#ff0';
                ctx.lineWidth = 2;
                ctx.strokeRect(x - ladderWidth/2 - 5, y - 5, ladderWidth + 10, height + 10);
            }

            ctx.restore();
        }

        function drawPlayerStart(x, y, selected) {
            ctx.save();

            // í”Œë ˆì´ì–´ ëª¨ì–‘
            ctx.fillStyle = '#4a90d9';
            ctx.fillRect(x, y - 32, 24, 24);

            ctx.fillStyle = '#ffdbac';
            ctx.beginPath();
            ctx.arc(x + 12, y - 36, 10, 0, Math.PI * 2);
            ctx.fill();

            // ì‹œì‘ì  í‘œì‹œ
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 3]);
            ctx.beginPath();
            ctx.arc(x + 12, y - 24, 30, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.fillStyle = '#00ff00';
            ctx.font = 'bold 10px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('START', x + 12, y + 15);

            if (selected) {
                ctx.strokeStyle = '#ff0';
                ctx.lineWidth = 2;
                ctx.strokeRect(x - 20, y - 55, 64, 75);
            }

            ctx.restore();
        }

        // Stage Connectorì—ì„œ ì—´ë ¸ì„ ë•Œ ìë™ ë¡œë“œ
        function loadFromConnector() {
            const params = new URLSearchParams(window.location.search);
            if (params.get('from') !== 'connector') return false;

            const stageId = localStorage.getItem('stageConnector_editStageId');
            const dataStr = localStorage.getItem('stageConnector_editStageData');
            if (!stageId || !dataStr) return false;

            try {
                const data = JSON.parse(dataStr);
                const defaultBg = {
                    skyTop: '#87CEEB', skyBottom: '#E0F6FF',
                    mountains: [
                        { x1: 0, peak: 150, x2: 300, color: '#9DC183' },
                        { x1: 200, peak: 200, x2: 600, color: '#7CAF6B' },
                        { x1: 500, peak: 120, x2: 900, color: '#9DC183' },
                        { x1: 800, peak: 180, x2: 1200, color: '#7CAF6B' }
                    ]
                };
                stageData = {
                    number: data.number || 0,
                    displayName: data.displayName || "",
                    playerStart: data.playerStart || { x: 100, y: 500 },
                    platforms: data.platforms || [],
                    monsters: data.monsters || [],
                    items: data.items || [],
                    portals: data.portals || [],
                    spawners: data.spawners || [],
                    ladders: data.ladders || [],
                    background: data.background || defaultBg
                };
                document.getElementById('stageName').value = stageId;
                document.getElementById('stageDisplayName').value = stageData.displayName;
                updateBgUI();
                selectedObject = null;
                updateJSON();
                updatePropertyPanel();
                render();

                // ì œëª©ì— ìŠ¤í…Œì´ì§€ ì´ë¦„ í‘œì‹œ
                document.title = `Level Editor - ${stageId} (${stageData.displayName})`;

                return true;
            } catch (err) {
                console.warn('Connector ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', err);
                return false;
            }
        }

        // Connectorì—ì„œ ì—´ë ¸ì„ ë•Œ: ì €ì¥ ì‹œ ê²°ê³¼ë¥¼ Connectorë¡œ ì „ë‹¬
        function sendBackToConnector() {
            const params = new URLSearchParams(window.location.search);
            if (params.get('from') !== 'connector') return;

            const stageId = localStorage.getItem('stageConnector_editStageId');
            if (!stageId) return;

            updateJSON();
            localStorage.setItem('stageConnector_editResult', JSON.stringify({
                id: stageId,
                data: stageData
            }));
        }

        // ê¸°ì¡´ saveJSONì„ ê°ì‹¸ì„œ Connector ì—°ë™ ì¶”ê°€
        const _origSaveJSON = saveJSON;
        saveJSON = async function() {
            await _origSaveJSON();
            sendBackToConnector();
        };

        // ì´ˆê¸°í™” ì‹¤í–‰
        init();
        loadFromConnector();
    </script>
</body>
</html>
